<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Customizable Image Notifications</title>
</head>
<body>
  <h1>Last Image Sent as Notification:</h1>
  
  <!-- Toggle Notifications button -->
  <button id="toggleNotifications">Enable Notifications</button>
  
  <!-- Tags Input and Update Button -->
  <div>
    <label for="tagInput">Enter Tags:</label>
    <input type="text" id="tagInput" placeholder="-ai_generated -scat -vore" />
    <button id="updateTags">Update Tags</button>
  </div>
  
  <!-- Display Current Tags -->
  <p>Current Tags: <span id="currentTags">None</span></p>
  
  <!-- Interval Input -->
  <div>
    <label for="intervalInput">Notification Interval (ms):</label>
    <input type="number" id="intervalInput" value="10000" />
  </div>
  
  <!-- Display Last Image -->
  <img id="lastImage" src="" alt="Last notification image will appear here" style="max-width: 100%; height: auto;"/>
  
  <script>
    let notificationsEnabled = false; // Start with notifications disabled
    let tags = ""; // Start with an empty tag list
    const impliedOrder = "order:random"; // Implied order
    let images = [];
    let page = 1;
    let worker;
    let notificationInterval = 10000; // Default interval (10 seconds)

    // Update displayed tags
    function updateDisplayedTags() {
      const displayTags = tags.trim() ? `${tags} ${impliedOrder}` : "None";
      document.getElementById('currentTags').innerText = displayTags;
    }

    // Toggle notifications and start/stop the worker
    document.getElementById("toggleNotifications").addEventListener("click", function () {
      notificationsEnabled = !notificationsEnabled;
      this.innerText = notificationsEnabled ? 'Disable Notifications' : 'Enable Notifications';

      if (notificationsEnabled) {
        startWorker(); // Start notifications
      } else {
        stopWorker(); // Stop notifications
      }
    });

    // Update tags based on user input
    document.getElementById("updateTags").addEventListener("click", function () {
      const userTags = document.getElementById("tagInput").value.trim();
      tags = userTags; // Update tags with user input
      images = []; // Clear existing images
      page = 1; // Reset page count
      updateDisplayedTags(); // Update displayed tags
      console.log("Tags updated to:", tags);
    });

    // Update notification interval from input box
    document.getElementById("intervalInput").addEventListener("input", function () {
      notificationInterval = parseInt(this.value) || 10000; // Default to 10 seconds if input is invalid
      if (notificationsEnabled) {
        stopWorker(); // Stop current worker
        startWorker(); // Restart with new interval
      }
    });

    // Request notification permission on page load
    async function requestNotificationPermission() {
      const permission = await Notification.requestPermission();
      if (permission !== "granted") {
        console.log("Notification permission denied.");
        notificationsEnabled = false;
        document.getElementById("toggleNotifications").innerText = 'Enable Notifications';
      } else {
        console.log("Notification permission granted.");
      }
    }

    // Shuffle images
    function shuffle(array) {
      let currentIndex = array.length;
      while (currentIndex !== 0) {
        let randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
      }
    }

    // Fetch images from the API
    async function fetchImages() {
      const apiUrl = `https://api.rule34.xxx/index.php?page=dapi&s=post&q=index&json=1&tags=${encodeURIComponent(tags)}+${encodeURIComponent(impliedOrder)}&pid=${page}`;
      const res = await fetch(apiUrl);
      let json = await res.json();
      json = json.filter((x) => !x.file_url.includes('mp4'));
      if (!json.length) return await fetchImages();
      images.push(...json);
      page++;
    }

    // Handle pinging and showing notifications
    async function ping() {
      if (!notificationsEnabled) return; // Do nothing if notifications are disabled

      if (images.length < 100) {
        await fetchImages();
      }
      shuffle(images);
      const imgData = images.shift(); // Get image data
      const imgUrl = imgData.file_url;
      const postUrl = `https://rule34.xxx/index.php?page=post&s=view&id=${imgData.id}`; // Construct the post URL

      const url = 'https://corsproxy.io/?' + encodeURIComponent(imgUrl);
      const res = await fetch(url);
      const icon = await res.blob();
      const imageURL = URL.createObjectURL(icon);

      // Only send notification if notificationsEnabled and permission is granted
      if (notificationsEnabled && Notification.permission === "granted") {
        const notification = new Notification('', { image: imageURL });

        // Attach a click event listener to the notification
        notification.onclick = function () {
          window.open(postUrl, '_blank'); // Open the post in a new tab
          notification.close(); // Close the notification on click
        };
      }

      // Update the image on the web page
      document.getElementById('lastImage').src = imageURL;
    }

    // Start the web worker
    function startWorker() {
      if (typeof Worker !== "undefined") {
        if (worker == undefined) {
          worker = new Worker('worker.js'); // Load the Web Worker
        }
        // Start the worker with the current interval
        worker.postMessage({ command: 'start', interval: notificationInterval });

        // Listen for the "ping" message from the worker
        worker.onmessage = function (e) {
          if (e.data === 'ping') {
            ping();
          }
        };
      } else {
        console.log("Web Workers are not supported in this browser.");
      }
    }

    // Stop the web worker
    function stopWorker() {
      if (worker) {
        worker.postMessage({ command: 'stop' });
      }
    }

    // Initialize everything on page load
    requestNotificationPermission();
    updateDisplayedTags(); // Initialize displayed tags

    // Ensure the worker is stopped when the page is closed
    window.onbeforeunload = function () {
      stopWorker();
    };
  </script>
</body>
</html>
