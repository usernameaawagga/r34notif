<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Customizable Image Notifications</title>
  <style>
    #intervalInput {
      width: 60px;
    }
    #lastImage {
      max-width: 100%;
      height: auto;
      max-height: 500px;
    }
  </style>
</head>
<body>
  <button id="toggleNotifications">Enable</button>
  <div>
    <label for="tagInput">Enter Tags:</label>
    <input type="text" id="tagInput" placeholder="-ai_generated score:>=10" />
    <button id="updateTags">Update Tags</button>
  </div>
  <p>Current Tags: <span id="currentTags">None</span></p>

  <div>
    <label for="intervalInput">Set interval in seconds (Default: 10):</label>
    <input type="number" id="intervalInput" placeholder="10" min="1" />
    <button id="updateInterval">Update Interval</button>
    <p>Current Interval: <span id="currentInterval">10</span> seconds</p>
  </div>

  <button id="forceImage">Force Image</button>
  <img id="lastImage" src="" alt="Last image will appear here" />

  <script>
    let notificationsEnabled = false;
    let tags = "";
    const impliedTags = "-ai_generated -vore score:>=10 -fart* -scat -watersports* -diaper* -pee* -poop -multi*breast* -feces* sort:random";
    let images = [];
    let page = 1;
    let worker;
    let interval = 10000;
    let retries = 0;
    const maxRetries = 5;
    let isProcessing = false;

    function updateDisplayedTags() {
      const displayTags = tags.trim() ? tags : "None";
      document.getElementById('currentTags').innerText = displayTags;
    }

    function updateDisplayedInterval() {
      document.getElementById('currentInterval').innerText = interval / 1000;
    }

    document.getElementById("toggleNotifications").addEventListener("click", function () {
      notificationsEnabled = !notificationsEnabled;
      this.innerText = notificationsEnabled ? 'Disable' : 'Enable';
      if (notificationsEnabled) {
        startWorker();
      } else {
        stopWorker();
      }
    });

    document.getElementById("updateTags").addEventListener("click", function () {
      const userTags = document.getElementById("tagInput").value.trim();
      tags = userTags || "-ai_generated -vore score:>=10";
      images = [];
      page = 1;
      updateDisplayedTags();
      console.log("Tags updated to:", tags);
    });

    document.getElementById("forceImage").addEventListener("click", async function () {
      if (!isProcessing) await ping();
    });

    document.getElementById("tagInput").addEventListener("keydown", function(event) {
      if (event.key === "Enter") {
        event.preventDefault();
        document.getElementById("updateTags").click();
      }
    });

    document.getElementById("intervalInput").addEventListener("keydown", function(event) {
      if (event.key === "Enter") {
        event.preventDefault();
        document.getElementById("updateInterval").click();
      }
    });

    document.getElementById("updateInterval").addEventListener("click", function () {
      const userInterval = parseInt(document.getElementById("intervalInput").value, 10);
      if (!isNaN(userInterval) && userInterval > 0) {
        interval = userInterval * 1000;
        console.log(`Interval updated to: ${userInterval} seconds`);
        updateDisplayedInterval();
        if (notificationsEnabled) {
          stopWorker();
          startWorker();
        }
      } else {
        alert("Please enter a valid interval in seconds.");
      }
    });

    async function fetchImagesBatch(pages) {
      try {
        const requests = pages.map((p) => {
          const apiUrl = `https://api.rule34.xxx/index.php?page=dapi&s=post&q=index&json=1&tags=${encodeURIComponent(tags)}+${encodeURIComponent(impliedTags)}&limit=100&pid=${p}`;
          return fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(apiUrl)}`).then((res) => res.json());
        });

        const results = await Promise.all(requests);
        const flattenedResults = results.flatMap((result) => {
          try {
            const json = JSON.parse(result.contents);
            return json.filter((x) => x.file_url && !x.file_url.includes('mp4'));
          } catch {
            console.error("Failed to parse batch result:", result);
            return [];
          }
        });

        images.push(...flattenedResults);
        retries = 0;
      } catch (error) {
        console.error("Error fetching images in batch:", error);
      }
    }

    async function ping() {
      if (!notificationsEnabled && !isProcessing) return;
      isProcessing = true;
      if (images.length < 100) {
        const batchSize = 3;
        const pages = Array.from({ length: batchSize }, (_, i) => page + i);
        page += batchSize;
        await fetchImagesBatch(pages);
      }

      if (images.length === 0) {
        console.log("No images to display.");
        isProcessing = false;
        return;
      }

      shuffle(images);
      const imgData = images.shift();
      if (!imgData || !imgData.file_url) {
        console.log("Invalid image data received:", imgData);
        isProcessing = false;
        return;
      }

      const imgUrl = imgData.file_url;
      const postUrl = `https://rule34.xxx/index.php?page=post&s=view&id=${imgData.id}`;
      const proxiedUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(imgUrl)}`;

      try {
        const res = await fetch(proxiedUrl);
        const proxyData = await res.json();
        const blob = await fetch(proxyData.contents).then((r) => r.blob());
        const imageURL = URL.createObjectURL(blob);

        if (notificationsEnabled && Notification.permission === "granted") {
          const notification = new Notification("New Image", { image: imageURL });
          notification.onclick = function () {
            window.open(postUrl, '_blank');
            notification.close();
          };
        }

        document.getElementById('lastImage').src = imageURL;
      } catch (error) {
        console.error("Failed to load image:", error);
      }

      isProcessing = false;
    }

    function shuffle(array) {
      let currentIndex = array.length;
      while (currentIndex !== 0) {
        let randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
      }
    }

    function startWorker() {
      if (typeof Worker !== "undefined") {
        if (worker == undefined) {
          worker = new Worker('worker.js');
        }
        worker.postMessage({ command: 'start', interval });
        worker.onmessage = function (e) {
          if (e.data === 'ping') {
            ping();
          }
        };
      } else {
        console.log("Web Workers are not supported in this browser.");
      }
    }

    function stopWorker() {
      if (worker) {
        worker.postMessage({ command: 'stop' });
      }
    }

    async function requestNotificationPermission() {
      const permission = await Notification.requestPermission();
      if (permission !== "granted") {
        notificationsEnabled = false;
        document.getElementById("toggleNotifications").innerText = 'Enable';
      }
    }

    requestNotificationPermission();
    updateDisplayedTags();
    updateDisplayedInterval();

    window.onbeforeunload = function () {
      stopWorker();
    };
  </script>
</body>
</html>
