<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Customizable Image Notifications</title>
  <style>
    /* Style for the interval input box */
    #intervalInput {
      width: 60px;
    }
    /* Fixed width for the tag input box to fit the example tags */
    #tagInput {
      width: 270px; /* Fixed width to accommodate '-ai_generated -vore score:>=10' */
      padding: 4px;
    }
  </style>
</head>
<body>
  <h1>Last Image Sent:</h1>
  <button id="toggleNotifications">Enable</button>
  <div>
    <label for="tagInput">Enter Tags:</label>
    <input type="text" id="tagInput" placeholder="-ai_generated -vore score:>=10" />
    <button id="updateTags">Update Tags</button>
  </div>
  <p>Current Tags: <span id="currentTags">None</span></p>

  <div>
    <label for="intervalInput">Set interval in seconds (Default: 10):</label>
    <input type="number" id="intervalInput" placeholder="10" min="1" />
    <button id="updateInterval">Update Interval</button>
    <p>Current Interval: <span id="currentInterval">10</span> seconds</p>
  </div>

  <img id="lastImage" src="" alt="Last image will appear here" style="max-width: 100%; height: auto;"/>

  <script>
    let notificationsEnabled = false; // Start disabled
    let tags = "-ai_generated -vore score:>=10"; // Default tags
    const impliedTags = "-fart* -scat -watersports* -diaper* -pee* -poop -multi*breast* -feces*"; // Additional implied tags
    const impliedOrder = "sort:random"; // Implied order tag
    let images = [];
    let page = 1;
    let worker;
    let interval = 10000; // Default interval in milliseconds (10 seconds)
    let retries = 0;
    const maxRetries = 5;
    let isProcessing = false; // Flag to track ongoing fetch

    // Update displayed tags (excluding the implied order)
    function updateDisplayedTags() {
      const displayTags = tags.trim() ? `${tags}` : "None";
      document.getElementById('currentTags').innerText = displayTags;
    }

    // Update displayed current interval
    function updateDisplayedInterval() {
      document.getElementById('currentInterval').innerText = interval / 1000; // Convert ms to seconds
    }

    document.getElementById("toggleNotifications").addEventListener("click", function () {
      notificationsEnabled = !notificationsEnabled;
      this.innerText = notificationsEnabled ? 'Disable' : 'Enable';

      if (notificationsEnabled) {
        startWorker(); // Start notifications and image updates
      } else {
        stopWorker(); // Stop notifications (but don't clear the image)
      }
    });

    document.getElementById("updateTags").addEventListener("click", function () {
      const userTags = document.getElementById("tagInput").value.trim();
      tags = userTags === "" ? "-ai_generated -vore score:>=10" : userTags; // Update tags if provided
      images = []; // Clear existing images
      page = 1; // Reset page count
      updateDisplayedTags();
      console.log("Tags updated to:", tags);
    });

    // Trigger the 'Update Tags' button when Enter key is pressed in the input field
    document.getElementById("tagInput").addEventListener("keydown", function(event) {
      if (event.key === "Enter") {  // Check if the Enter key was pressed
        event.preventDefault();  // Prevent form submission if inside a form
        document.getElementById("updateTags").click();  // Trigger the 'Update Tags' button click
      }
    });

    // Trigger the 'Update Interval' button when Enter key is pressed in the input field
    document.getElementById("intervalInput").addEventListener("keydown", function(event) {
      if (event.key === "Enter") {  // Check if the Enter key was pressed
        event.preventDefault();  // Prevent form submission if inside a form
        document.getElementById("updateInterval").click();  // Trigger the 'Update Interval' button click
      }
    });

    document.getElementById("updateInterval").addEventListener("click", function () {
      const userInterval = parseInt(document.getElementById("intervalInput").value, 10);
      if (!isNaN(userInterval) && userInterval > 0) {
        interval = userInterval * 1000; // Convert seconds to milliseconds
        console.log(`Interval updated to: ${userInterval} seconds`);
        updateDisplayedInterval(); // Update displayed interval
        if (notificationsEnabled) {
          stopWorker();
          startWorker(); // Restart worker with new interval
        }
      } else {
        alert("Please enter a valid interval in seconds.");
      }
    });

    async function requestNotificationPermission() {
      const permission = await Notification.requestPermission();
      if (permission !== "granted") {
        console.log("Notification permission denied.");
        notificationsEnabled = false;
        document.getElementById("toggleNotifications").innerText = 'Enable';
      } else {
        console.log("Notification permission granted.");
      }
    }

    function shuffle(array) {
      let currentIndex = array.length;
      while (currentIndex !== 0) {
        let randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
      }
    }

    async function fetchImages() {
      try {
        const apiUrl = `https://api.rule34.xxx/index.php?page=dapi&s=post&q=index&json=1&tags=${encodeURIComponent(tags)}+${encodeURIComponent(impliedOrder)}+${encodeURIComponent(impliedTags)}&pid=${page}`;
        const res = await fetch(apiUrl);

        if (!res.ok) {
          console.error(`Failed to fetch images. HTTP status: ${res.status}`);
          return;
        }

        const text = await res.text(); // Get response as text
        let json;

        // Check if response is empty
        if (text.trim() === "") {
          console.error("Empty response received from the API.");
          if (retries < maxRetries) {
            retries++;
            page++;
            return await fetchImages(); // Retry
          } else {
            console.error("Max retries reached.");
            return;
          }
        }

        try {
          json = JSON.parse(text); // Try to parse JSON
        } catch (e) {
          console.error("Failed to parse JSON response:", e);
          console.error("Response text:", text);
          return;
        }

        // Filter out unwanted file types
        json = json.filter((x) => x.file_url && !x.file_url.includes('mp4'));

        if (json.length === 0) {
          console.log("No images found with the current tags. Retrying...");
          retries++;
          page++;
          return await fetchImages();
        }

        // Reset retries if we get valid images
        retries = 0;

        // If there are valid images, add them to the array
        images.push(...json);
        page++;

      } catch (error) {
        console.error("Error fetching images:", error);
      }
    }

    async function ping() {
      if (!notificationsEnabled || isProcessing) return; // Do nothing if notifications are disabled or if already processing

      isProcessing = true; // Mark as processing

      if (images.length < 100) {
        await fetchImages();
      }

      // Ensure there are images to show
      if (images.length === 0) {
        console.log("No images to display.");
        isProcessing = false; // Mark as done processing
        return;
      }

      shuffle(images);
      const imgData = images.shift(); // Get image data

      // Check if imgData has file_url before proceeding
      if (!imgData || !imgData.file_url) {
        console.log("Invalid image data received:", imgData);
        isProcessing = false; // Mark as done processing
        return;
      }

      const imgUrl = imgData.file_url;
      const postUrl = `https://rule34.xxx/index.php?page=post&s=view&id=${imgData.id}`; // Construct the post URL

      const url = 'https://corsproxy.io/?' + encodeURIComponent(imgUrl);
      const res = await fetch(url);
      const icon = await res.blob();
      const imageURL = URL.createObjectURL(icon);

      // Only send notification if notificationsEnabled and permission is granted
      if (notificationsEnabled && Notification.permission === "granted") {
        const notification = new Notification('', { image: imageURL });

        // Attach a click event listener to the notification
        notification.onclick = function () {
          window.open(postUrl);
        };
      }

      // Update the last image shown in the browser
      document.getElementById('lastImage').src = imgUrl;

      isProcessing = false; // Mark as done processing
    }

    function startWorker() {
      worker = setInterval(ping, interval);
    }

    function stopWorker() {
      clearInterval(worker);
    }

    // Initially request notification permission
    requestNotificationPermission();

    // Set initial values
    updateDisplayedTags();
    updateDisplayedInterval();
  </script>
</body>
</html>
