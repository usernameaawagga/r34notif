<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Customizable Image Notifications</title>
  <style>
    body { font-family: sans-serif; line-height: 1.6; padding: 1em; max-width: 800px; margin: auto; }
    input[type="text"], input[type="number"] { padding: 5px; }
    button { padding: 5px 10px; cursor: pointer; }
    #lastImage {
      max-width: 100%;
      height: auto;
      max-height: 600px;
      margin-top: 1em;
      display: block;
      border: 1px solid #ccc;
    }
    div { margin-bottom: 1em; }
    p { margin: 0.5em 0; }
  </style>
</head>
<body>
  <button id="toggleNotifications">Enable</button>
  <div>
    <label for="tagInput">Enter Tags:</label>
    <input type="text" id="tagInput" placeholder="-ai_generated score:>=10" />
    <button id="updateTags">Update Tags</button>
  </div>
  <p>Current Tags: <span id="currentTags">None</span></p>

  <div>
    <label for="intervalInput">Set interval in seconds (Default: 10):</label>
    <input type="number" id="intervalInput" placeholder="10" min="1" />
    <button id="updateInterval">Update Interval</button>
    <p>Current Interval: <span id="currentInterval">10</span> seconds</p>
  </div>

  <button id="forceImageButton">Force image</button>

  <img id="lastImage" src="" alt="Images will appear here once the queue is loaded." />

  <script>
    let notificationsEnabled = false;
    let tags = "-ai_generated score:>=10";
    const impliedTags = "-fart* -scat -watersports* -diaper* -pee* -poop -multi*breast* -feces* sort:random";
    let images = [];
    let worker;
    let interval = 10000;
    let isProcessing = false;
    const IMAGE_BUFFER_THRESHOLD = 50;

    function updateDisplayedTags() {
      document.getElementById('currentTags').innerText = tags.trim() ? tags : "None";
    }

    function updateDisplayedInterval() {
      document.getElementById('currentInterval').innerText = interval / 1000;
    }

    function updateTags() {
      const userTags = document.getElementById("tagInput").value.trim();
      tags = userTags || "-ai_generated score:>=10";
      images = [];
      updateDisplayedTags();
      console.log("Tags updated to:", tags);
      if (worker) {
          stopWorker();
          if (notificationsEnabled) {
              startWorker();
          }
      }
    }

    document.getElementById("toggleNotifications").addEventListener("click", function () {
      notificationsEnabled = !notificationsEnabled;
      this.innerText = notificationsEnabled ? 'Disable' : 'Enable';
      if (notificationsEnabled) {
        requestNotificationPermission().then(granted => {
            if(granted) startWorker();
        });
      } else {
        stopWorker();
      }
    });

    document.getElementById("updateTags").addEventListener("click", updateTags);

    document.getElementById("intervalInput").addEventListener("keydown", function(event) {
      if (event.key === "Enter") {
        event.preventDefault();
        document.getElementById("updateInterval").click();
      }
    });

    document.getElementById("updateInterval").addEventListener("click", function () {
      const userInterval = parseInt(document.getElementById("intervalInput").value, 10);
      if (!isNaN(userInterval) && userInterval > 0) {
        interval = userInterval * 1000;
        console.log(`Interval updated to: ${userInterval} seconds`);
        updateDisplayedInterval();
        if (notificationsEnabled) {
          stopWorker();
          startWorker();
        }
      } else {
        alert("Please enter a valid interval in seconds.");
      }
    });

    async function requestNotificationPermission() {
      if (Notification.permission === "granted") return true;
      if (Notification.permission === "denied") {
          alert("Notification permission has been denied. Please enable it in your browser settings.");
          return false;
      }
      const permission = await Notification.requestPermission();
      if (permission !== "granted") {
        notificationsEnabled = false;
        document.getElementById("toggleNotifications").innerText = 'Enable';
        return false;
      }
      return true;
    }

    async function showImage() {
      if (isProcessing) return;

      if (images.length === 0) {
        console.log("No images in queue. Requesting more from worker...");
        if (worker) worker.postMessage({ command: 'getMoreImages' });
        return;
      }
      isProcessing = true;

      const imgData = images.shift();

      if (images.length < IMAGE_BUFFER_THRESHOLD && worker) {
          console.log(`Image queue low (${images.length}). Requesting more.`);
          worker.postMessage({ command: 'getMoreImages' });
      }

      const imgUrl = imgData.file_url;
      const postUrl = `https://rule34.xxx/index.php?page=post&s=view&id=${imgData.id}`;
      
      // Use a CORS proxy to fetch the image data.
      const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(imgUrl)}`;

      try {
        const res = await fetch(proxyUrl);
        if (!res.ok) throw new Error(`Proxy fetch failed with status ${res.status}`);
        
        const blob = await res.blob();
        const imageURL = URL.createObjectURL(blob);

        document.getElementById('lastImage').src = imageURL;

        if (Notification.permission === "granted") {
          const notification = new Notification('New Image', { image: imageURL, silent: true });
          notification.onclick = function () {
            window.open(postUrl, '_blank');
            notification.close();
          };
        }
      } catch (error) {
          console.error("Error fetching or displaying image:", error);
          // Put the failed image back in the queue to try later
          images.unshift(imgData);
      } finally {
        isProcessing = false;
      }
    }

    document.getElementById('forceImageButton').addEventListener('click', showImage);

    function startWorker() {
      if (typeof Worker !== "undefined") {
        if (worker) stopWorker(); // Ensure no old worker is running

        worker = new Worker('worker.js');
        worker.onmessage = function (e) {
          const { type, images: newImages, error, message } = e.data;
          if (type === 'addImages') {
            const initialLoad = images.length === 0;
            // Filter out any duplicates already in the queue
            const uniqueNewImages = newImages.filter(newItem => !images.some(existingItem => existingItem.id === newItem.id));
            images.push(...uniqueNewImages);
            console.log(`Added ${uniqueNewImages.length} new images. Total in queue: ${images.length}`);
            if (initialLoad && notificationsEnabled) {
                showImage();
            }
          } else if (type === 'ping') {
              showImage();
          } else if (type === 'error') {
              console.error("Worker error:", error);
          } else if (type === 'message') {
              console.log("Worker message:", message);
          }
        };

        worker.postMessage({ command: 'start', interval, tags, impliedTags });
        // Immediately ask for the first batch of images
        worker.postMessage({ command: 'getMoreImages' });
      } else {
        alert("Web Workers are not supported in this browser.");
      }
    }

    function stopWorker() {
      if (worker) {
        worker.postMessage({ command: 'stop' });
        worker.terminate();
        worker = undefined;
        console.log("Worker stopped and terminated.");
      }
    }

    // Initial setup
    updateDisplayedTags();
    updateDisplayedInterval();
    window.onbeforeunload = stopWorker;
  </script>
</body>
</html>
